{"version":3,"file":"error-stack2.cjs.production.min.js","sources":["../src/util/trim.ts","../src/util/isUnset.ts","../src/util/isNumOnly.ts","../src/index.ts"],"sourcesContent":["export function trim(s: string)\n{\n\treturn s.trim();\n}\n","\nexport function isUnset(v: any): v is undefined | null\n{\n\treturn typeof v === 'undefined' || v === null\n}\n","\nexport function isNumOnly(v: any)\n{\n\tif (typeof v === 'number' || typeof v === 'string')\n\t{\n\t\treturn /^\\d+$/.test(v.toString())\n\t}\n\n\treturn false\n}\n","import { ITSPickExtra, ITSRequireAtLeastOne } from 'ts-type/lib/type/record';\nimport { lineSplit, R_CRLF } from 'crlf-normalize';\nimport { IEvalTrace, IParsed, IParsedWithoutTrace, ISource, ITrace, IRawLineTrace, ITraceValue } from './types';\n// @ts-ignore\nimport ssplit from 'string-split-keep';\nimport { trim } from './util/trim';\nimport { isUnset } from './util/isUnset';\nimport { isNumOnly } from './util/isNumOnly';\nimport errcode from 'err-code';\nimport { inspect } from 'util';\n\nconst AT = 'at' as const\nconst CR = '\\n' as const\n\n// 1.\n// Error: foo\n// 2.\n// TypeError: foo\nconst REGEX_MATCH_MESSAGE = /^([a-z][a-z0-9_]*)(?: \\[(\\w+)\\])?:(?: ([\\s\\S]*))?$/i\n\nconst REGEX_REMOVE_AT = /^at\\s+/\nconst REGEX_STARTS_WITH_EVAL_AT = /^eval\\s+at\\s+/\n\nconst REGEX_MATCH_INDENT = /^([ \\t]*)(.+)$/;\n\nexport function breakBrackets(str: string, first: string, last: string)\n{\n\tif (!str.endsWith(last))\n\t{\n\t\treturn [str]\n\t}\n\n\tlet firstIndex\n\tlet cursor = str.length - 1\n\t// There is already the last one\n\tlet count = 1\n\twhile (--cursor >= 0)\n\t{\n\t\tconst char = str.charAt(cursor)\n\t\tif (char === last)\n\t\t{\n\t\t\tcount++\n\t\t}\n\t\telse if (char === first)\n\t\t{\n\t\t\tif (--count === 0)\n\t\t\t{\n\t\t\t\tfirstIndex = cursor\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [\n\t\tstr.slice(0, firstIndex),\n\t\tstr.slice(firstIndex + 1, -1),\n\t].map(trim)\n}\n\nexport function validPosition(source: {\n\tline?: string | number,\n\tcol?: string | number,\n})\n{\n\tif (!isUnset(source))\n\t{\n\t\tif (typeof source === 'object' && isUnset(source.line) && isUnset(source.col))\n\t\t{\n\t\t\treturn null\n\t\t}\n\n\t\treturn isNumOnly(source.line) && isNumOnly(source.col)\n\t}\n\n\treturn false\n}\n\nexport function parseSource(rawSource: string): ISource\n{\n\tconst [source, line, col] = ssplit(rawSource, ':', -3);\n\n\tif (!col?.length || !line?.length)\n\t{\n\t\treturn {\n\t\t\tsource: rawSource,\n\t\t}\n\t}\n\n\treturn {\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t}\n}\n\nexport function parseEvalSource(rawEvalSource: string): Omit<IEvalTrace, 'callee' | 'calleeNote' | 'eval'>\n{\n\tconst { indent, rawLine } = _detectIndent(rawEvalSource);\n\n\tconst [rawTrace, rawEvalTrace] = rawLine\n\t\t.replace(REGEX_STARTS_WITH_EVAL_AT, '')\n\t\t.split(/,\\s+/g)\n\t\t.map(trim)\n\n\tconst {\n\t\teval: ev,\n\t\tcallee: evalCallee,\n\t\tcalleeNote: evalCalleeNote,\n\t\t...trace\n\t} = parseTrace(rawTrace)\n\n\tconst evalTrace = parseSource(rawEvalTrace)\n\n\treturn {\n\t\tevalCallee,\n\t\tevalCalleeNote,\n\t\t...trace,\n\t\tevalTrace,\n\t\tindent,\n\t}\n}\n\nexport function _detectIndent(trace: string)\n{\n\tconst [, indent, rawLine] = REGEX_MATCH_INDENT.exec(trace)\n\n\treturn {\n\t\tindent,\n\t\trawLine,\n\t}\n}\n\nexport function parseTrace(trace: string, testEvalSource: true): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: false): ITrace\nexport function parseTrace(trace: string, testEvalSource?: boolean): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: boolean)\n{\n\tconst { indent, rawLine } = _detectIndent(trace);\n\n\tconst t = rawLine.replace(REGEX_REMOVE_AT, '')\n\n\tlet [\n\t\trawCallee, rawSource,\n\t] = breakBrackets(t, '(', ')')\n\n\tif (!rawSource)\n\t{\n\t\t[rawCallee, rawSource] = [rawSource, rawCallee]\n\t}\n\n\tconst ret: ITrace = {} as any\n\n\tif (rawCallee)\n\t{\n\t\tconst [\n\t\t\tcallee, calleeNote,\n\t\t] = breakBrackets(rawCallee, '[', ']')\n\n\t\tret.callee = callee\n\t\tret.calleeNote = calleeNote\n\t}\n\telse\n\t{\n\t\tret.callee = rawCallee\n\t}\n\n\tif (ret.callee === 'eval')\n\t{\n\t\tret.eval = true\n\t}\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!rawLine.startsWith(AT))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.assign(\n\t\tret,\n\t\ttestEvalSource && isEvalSource(rawSource)\n\t\t\t? parseEvalSource(rawSource)\n\t\t\t: parseSource(rawSource),\n\t)\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!validTrace(ret))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tret.indent = indent\n\n\treturn ret\n}\n\nexport function isEvalSource(rawSource: string)\n{\n\treturn REGEX_STARTS_WITH_EVAL_AT.test(rawSource)\n}\n\nexport function validTrace(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn false;\n\t}\n\n\treturn trace.eval || isNumOnly(trace.line) || isUnset(trace.callee) && trace.source?.length > 0 && validPosition(trace);\n}\n\nexport function parseBody(rawStack: string, detectMessage?: string)\n{\n\tlet rawTrace: string[];\n\tlet rawMessage: string\n\n\tif (!isUnset(detectMessage))\n\t{\n\t\tlet { type } = parseMessage(rawStack);\n\n\t\tlet mf = formatMessage({\n\t\t\ttype,\n\t\t\tmessage: detectMessage,\n\t\t});\n\n\t\tlet i = rawStack.indexOf(mf)\n\n\t\tif (i === 0)\n\t\t{\n\t\t\tlet s = rawStack.replace(mf, '')\n\t\t\tlet m = R_CRLF.exec(s)\n\n\t\t\tif (m?.index === 0)\n\t\t\t{\n\t\t\t\trawTrace = lineSplit(m.input.replace(m[0], ''));\n\n\t\t\t\trawMessage = mf\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rawMessage?.length)\n\t{\n\t\t([rawMessage, ...rawTrace] = lineSplit(rawStack));\n\n\t\t// A error message might have multiple lines\n\t\tconst index = rawTrace.findIndex(line => line.trimLeft().startsWith(AT) && validTrace(parseTrace(trim(line), true)))\n\n\t\trawMessage = [rawMessage, ...rawTrace.splice(0, index)].join(CR)\n\t}\n\n\treturn {\n\t\trawMessage,\n\t\trawTrace,\n\t}\n}\n\nexport function parseMessage(body: string): IParsedWithoutTrace\n{\n\ttry\n\t{\n\t\tconst [, type, code, message] = body.match(REGEX_MATCH_MESSAGE)\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\te.message = `Failed to parse error message.\\nreason: ${e.message}\\nbody=${inspect(body)}`;\n\n\t\terrcode(e, {\n\t\t\tbody,\n\t\t});\n\n\t\tthrow e\n\t}\n}\n\nexport function parseStack(rawStack: string, detectMessage?: string): IParsed\n{\n\tif (typeof rawStack !== 'string')\n\t{\n\t\tthrow new TypeError('stack must be a string')\n\t}\n\n\ttry\n\t{\n\t\tconst { rawMessage, rawTrace } = parseBody(rawStack, detectMessage);\n\n\t\tconst {\n\t\t\ttype, code, message,\n\t\t} = parseMessage(rawMessage)\n\n\t\tconst traces = rawTrace.map(t => parseTrace(t, true))\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t\ttraces,\n\t\t\trawMessage,\n\t\t\trawTrace,\n\t\t\trawStack,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\terrcode(e, {\n\t\t\trawStack,\n\t\t\tdetectMessage,\n\t\t});\n\n\t\tthrow e;\n\t}\n}\n\nexport function formatTrace({\n\tcallee,\n\tcalleeNote,\n\tsource,\n\tline,\n\tcol,\n}: ITSPickExtra<ITrace, 'source'>)\n{\n\tconst sourceTrace = [\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t]\n\t\t.filter(v => typeof v !== 'undefined')\n\t\t.join(':')\n\n\tconst note = calleeNote\n\t\t? ` [${calleeNote}]`\n\t\t: ''\n\n\treturn callee\n\t\t? `${callee}${note} (${sourceTrace})`\n\t\t: sourceTrace\n}\n\nexport function formatEvalTrace({\n\tcallee,\n\tevalTrace,\n\n\tevalCallee,\n\tevalCalleeNote,\n\n\t...trace\n}: IEvalTrace)\n{\n\treturn `${callee} (eval at ${formatTrace({\n\t\t...trace,\n\n\t\tcallee: evalCallee ?? '<anonymous>',\n\t\tcalleeNote: evalCalleeNote,\n\t})}, ${formatTrace(evalTrace)})`;\n}\n\nexport function formatMessagePrefix({\n\ttype,\n\tcode,\n}: IParsedWithoutTrace)\n{\n\tif (code?.length)\n\t{\n\t\ttype += ` [${code}]`;\n\t}\n\n\treturn `${type}`;\n}\n\nexport function formatMessage(parsed: IParsedWithoutTrace)\n{\n\treturn `${formatMessagePrefix(parsed)}: ${parsed.message ?? ''}`;\n}\n\nexport function formatRawLineTrace(trace: IRawLineTrace)\n{\n\treturn `${trace.indent ?? '    '}${trace.rawLine}`\n}\n\nexport function isRawLineTrace(trace: ITraceValue): trace is IRawLineTrace\n{\n\treturn (trace.raw === true)\n}\n\nexport function isEvalTrace(trace: ITraceValue): trace is IEvalTrace\n{\n\treturn (trace as IEvalTrace).eval === true\n}\n\nexport function formatTraceLine(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn formatRawLineTrace(trace)\n\t}\n\n\treturn `${trace.indent ?? '    '}at ${\n\t\tisEvalTrace(trace)\n\t\t\t? formatEvalTrace(trace)\n\t\t\t: formatTrace(trace)\n\t}`\n}\n\nexport class ErrorStack implements IParsed\n{\n\n\t/**\n\t * Error type\n\t */\n\ttype: string;\n\n\tcode?: string;\n\t/**\n\t * The message used by Error constructor\n\t */\n\tmessage: string;\n\ttraces: IParsed[\"traces\"];\n\n\treadonly rawMessage?: string;\n\treadonly rawTrace?: string[];\n\treadonly rawStack?: string;\n\n\tconstructor(stack: string, detectMessage?: string)\n\t{\n\t\tObject.assign(this, parseStack(stack, detectMessage))\n\t}\n\n\t/**\n\t * filterFunction Function the same as the callback function of Array.prototype.filter(callback)\n\t */\n\tfilter(filter: (value: ITraceValue, index: number, array: IParsed[\"traces\"]) => boolean)\n\t{\n\t\tthis.traces = this.traces.filter(filter)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Format object parsed\n\t */\n\tformat()\n\t{\n\t\treturn stringifyErrorStack(this)\n\t}\n}\n\nexport function formatTraces(traces: IParsed[\"traces\"])\n{\n\treturn traces?.map(formatTraceLine)\n}\n\n/**\n * Format object parsed\n */\nexport function stringifyErrorStack(parsed: ITSRequireAtLeastOne<IParsed, 'traces' | 'rawTrace'>)\n{\n\tconst messageLines = `${formatMessage(parsed)}`\n\tconst tracesLines = (parsed.traces?.map(formatTraceLine) ?? parsed.rawTrace)\n\t\t.join(CR)\n\n\treturn tracesLines\n\t\t? messageLines + CR + tracesLines\n\t\t: messageLines\n}\n\nexport function parseErrorStack(stack: string, detectMessage?: string)\n{\n\treturn new ErrorStack(stack, detectMessage)\n}\n\nexport default parseErrorStack\n"],"names":["trim","s","isUnset","v","isNumOnly","test","toString","REGEX_MATCH_MESSAGE","REGEX_REMOVE_AT","REGEX_STARTS_WITH_EVAL_AT","REGEX_MATCH_INDENT","breakBrackets","str","first","last","endsWith","firstIndex","cursor","length","count","char","charAt","slice","map","validPosition","source","line","col","parseSource","rawSource","ssplit","parseEvalSource","rawEvalSource","indent","rawLine","_detectIndent","rawTrace","rawEvalTrace","replace","split","eval","ev","callee","evalCallee","calleeNote","evalCalleeNote","trace","parseTrace","evalTrace","exec","testEvalSource","t","rawCallee","ret","startsWith","Object","assign","isEvalSource","validTrace","raw","isRawLineTrace","parseBody","rawStack","detectMessage","rawMessage","type","parseMessage","mf","formatMessage","message","indexOf","m","R_CRLF","index","lineSplit","input","_rawMessage","findIndex","trimLeft","splice","join","body","code","match","e","inspect","errcode","parseStack","TypeError","traces","formatTrace","sourceTrace","filter","formatEvalTrace","formatMessagePrefix","parsed","formatRawLineTrace","isEvalTrace","formatTraceLine","ErrorStack","constructor","stack","this","format","stringifyErrorStack","messageLines","tracesLines","_parsed$traces","parseErrorStack"],"mappings":"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"}