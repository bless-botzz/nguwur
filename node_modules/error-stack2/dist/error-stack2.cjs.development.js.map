{"version":3,"file":"error-stack2.cjs.development.js","sources":["../src/util/trim.ts","../src/util/isUnset.ts","../src/util/isNumOnly.ts","../src/index.ts"],"sourcesContent":["export function trim(s: string)\n{\n\treturn s.trim();\n}\n","\nexport function isUnset(v: any): v is undefined | null\n{\n\treturn typeof v === 'undefined' || v === null\n}\n","\nexport function isNumOnly(v: any)\n{\n\tif (typeof v === 'number' || typeof v === 'string')\n\t{\n\t\treturn /^\\d+$/.test(v.toString())\n\t}\n\n\treturn false\n}\n","import { ITSPickExtra, ITSRequireAtLeastOne } from 'ts-type/lib/type/record';\nimport { lineSplit, R_CRLF } from 'crlf-normalize';\nimport { IEvalTrace, IParsed, IParsedWithoutTrace, ISource, ITrace, IRawLineTrace, ITraceValue } from './types';\n// @ts-ignore\nimport ssplit from 'string-split-keep';\nimport { trim } from './util/trim';\nimport { isUnset } from './util/isUnset';\nimport { isNumOnly } from './util/isNumOnly';\nimport errcode from 'err-code';\nimport { inspect } from 'util';\n\nconst AT = 'at' as const\nconst CR = '\\n' as const\n\n// 1.\n// Error: foo\n// 2.\n// TypeError: foo\nconst REGEX_MATCH_MESSAGE = /^([a-z][a-z0-9_]*)(?: \\[(\\w+)\\])?:(?: ([\\s\\S]*))?$/i\n\nconst REGEX_REMOVE_AT = /^at\\s+/\nconst REGEX_STARTS_WITH_EVAL_AT = /^eval\\s+at\\s+/\n\nconst REGEX_MATCH_INDENT = /^([ \\t]*)(.+)$/;\n\nexport function breakBrackets(str: string, first: string, last: string)\n{\n\tif (!str.endsWith(last))\n\t{\n\t\treturn [str]\n\t}\n\n\tlet firstIndex\n\tlet cursor = str.length - 1\n\t// There is already the last one\n\tlet count = 1\n\twhile (--cursor >= 0)\n\t{\n\t\tconst char = str.charAt(cursor)\n\t\tif (char === last)\n\t\t{\n\t\t\tcount++\n\t\t}\n\t\telse if (char === first)\n\t\t{\n\t\t\tif (--count === 0)\n\t\t\t{\n\t\t\t\tfirstIndex = cursor\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn [\n\t\tstr.slice(0, firstIndex),\n\t\tstr.slice(firstIndex + 1, -1),\n\t].map(trim)\n}\n\nexport function validPosition(source: {\n\tline?: string | number,\n\tcol?: string | number,\n})\n{\n\tif (!isUnset(source))\n\t{\n\t\tif (typeof source === 'object' && isUnset(source.line) && isUnset(source.col))\n\t\t{\n\t\t\treturn null\n\t\t}\n\n\t\treturn isNumOnly(source.line) && isNumOnly(source.col)\n\t}\n\n\treturn false\n}\n\nexport function parseSource(rawSource: string): ISource\n{\n\tconst [source, line, col] = ssplit(rawSource, ':', -3);\n\n\tif (!col?.length || !line?.length)\n\t{\n\t\treturn {\n\t\t\tsource: rawSource,\n\t\t}\n\t}\n\n\treturn {\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t}\n}\n\nexport function parseEvalSource(rawEvalSource: string): Omit<IEvalTrace, 'callee' | 'calleeNote' | 'eval'>\n{\n\tconst { indent, rawLine } = _detectIndent(rawEvalSource);\n\n\tconst [rawTrace, rawEvalTrace] = rawLine\n\t\t.replace(REGEX_STARTS_WITH_EVAL_AT, '')\n\t\t.split(/,\\s+/g)\n\t\t.map(trim)\n\n\tconst {\n\t\teval: ev,\n\t\tcallee: evalCallee,\n\t\tcalleeNote: evalCalleeNote,\n\t\t...trace\n\t} = parseTrace(rawTrace)\n\n\tconst evalTrace = parseSource(rawEvalTrace)\n\n\treturn {\n\t\tevalCallee,\n\t\tevalCalleeNote,\n\t\t...trace,\n\t\tevalTrace,\n\t\tindent,\n\t}\n}\n\nexport function _detectIndent(trace: string)\n{\n\tconst [, indent, rawLine] = REGEX_MATCH_INDENT.exec(trace)\n\n\treturn {\n\t\tindent,\n\t\trawLine,\n\t}\n}\n\nexport function parseTrace(trace: string, testEvalSource: true): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: false): ITrace\nexport function parseTrace(trace: string, testEvalSource?: boolean): ITrace | IRawLineTrace\nexport function parseTrace(trace: string, testEvalSource?: boolean)\n{\n\tconst { indent, rawLine } = _detectIndent(trace);\n\n\tconst t = rawLine.replace(REGEX_REMOVE_AT, '')\n\n\tlet [\n\t\trawCallee, rawSource,\n\t] = breakBrackets(t, '(', ')')\n\n\tif (!rawSource)\n\t{\n\t\t[rawCallee, rawSource] = [rawSource, rawCallee]\n\t}\n\n\tconst ret: ITrace = {} as any\n\n\tif (rawCallee)\n\t{\n\t\tconst [\n\t\t\tcallee, calleeNote,\n\t\t] = breakBrackets(rawCallee, '[', ']')\n\n\t\tret.callee = callee\n\t\tret.calleeNote = calleeNote\n\t}\n\telse\n\t{\n\t\tret.callee = rawCallee\n\t}\n\n\tif (ret.callee === 'eval')\n\t{\n\t\tret.eval = true\n\t}\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!rawLine.startsWith(AT))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tObject.assign(\n\t\tret,\n\t\ttestEvalSource && isEvalSource(rawSource)\n\t\t\t? parseEvalSource(rawSource)\n\t\t\t: parseSource(rawSource),\n\t)\n\n\tif (testEvalSource === true)\n\t{\n\t\tif (!validTrace(ret))\n\t\t{\n\t\t\treturn <IRawLineTrace>{\n\t\t\t\traw: true,\n\t\t\t\tindent,\n\t\t\t\trawLine,\n\t\t\t}\n\t\t}\n\t}\n\n\tret.indent = indent\n\n\treturn ret\n}\n\nexport function isEvalSource(rawSource: string)\n{\n\treturn REGEX_STARTS_WITH_EVAL_AT.test(rawSource)\n}\n\nexport function validTrace(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn false;\n\t}\n\n\treturn trace.eval || isNumOnly(trace.line) || isUnset(trace.callee) && trace.source?.length > 0 && validPosition(trace);\n}\n\nexport function parseBody(rawStack: string, detectMessage?: string)\n{\n\tlet rawTrace: string[];\n\tlet rawMessage: string\n\n\tif (!isUnset(detectMessage))\n\t{\n\t\tlet { type } = parseMessage(rawStack);\n\n\t\tlet mf = formatMessage({\n\t\t\ttype,\n\t\t\tmessage: detectMessage,\n\t\t});\n\n\t\tlet i = rawStack.indexOf(mf)\n\n\t\tif (i === 0)\n\t\t{\n\t\t\tlet s = rawStack.replace(mf, '')\n\t\t\tlet m = R_CRLF.exec(s)\n\n\t\t\tif (m?.index === 0)\n\t\t\t{\n\t\t\t\trawTrace = lineSplit(m.input.replace(m[0], ''));\n\n\t\t\t\trawMessage = mf\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!rawMessage?.length)\n\t{\n\t\t([rawMessage, ...rawTrace] = lineSplit(rawStack));\n\n\t\t// A error message might have multiple lines\n\t\tconst index = rawTrace.findIndex(line => line.trimLeft().startsWith(AT) && validTrace(parseTrace(trim(line), true)))\n\n\t\trawMessage = [rawMessage, ...rawTrace.splice(0, index)].join(CR)\n\t}\n\n\treturn {\n\t\trawMessage,\n\t\trawTrace,\n\t}\n}\n\nexport function parseMessage(body: string): IParsedWithoutTrace\n{\n\ttry\n\t{\n\t\tconst [, type, code, message] = body.match(REGEX_MATCH_MESSAGE)\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\te.message = `Failed to parse error message.\\nreason: ${e.message}\\nbody=${inspect(body)}`;\n\n\t\terrcode(e, {\n\t\t\tbody,\n\t\t});\n\n\t\tthrow e\n\t}\n}\n\nexport function parseStack(rawStack: string, detectMessage?: string): IParsed\n{\n\tif (typeof rawStack !== 'string')\n\t{\n\t\tthrow new TypeError('stack must be a string')\n\t}\n\n\ttry\n\t{\n\t\tconst { rawMessage, rawTrace } = parseBody(rawStack, detectMessage);\n\n\t\tconst {\n\t\t\ttype, code, message,\n\t\t} = parseMessage(rawMessage)\n\n\t\tconst traces = rawTrace.map(t => parseTrace(t, true))\n\n\t\treturn {\n\t\t\ttype,\n\t\t\tcode,\n\t\t\tmessage,\n\t\t\ttraces,\n\t\t\trawMessage,\n\t\t\trawTrace,\n\t\t\trawStack,\n\t\t}\n\t}\n\tcatch (e: any)\n\t{\n\t\terrcode(e, {\n\t\t\trawStack,\n\t\t\tdetectMessage,\n\t\t});\n\n\t\tthrow e;\n\t}\n}\n\nexport function formatTrace({\n\tcallee,\n\tcalleeNote,\n\tsource,\n\tline,\n\tcol,\n}: ITSPickExtra<ITrace, 'source'>)\n{\n\tconst sourceTrace = [\n\t\tsource,\n\t\tline,\n\t\tcol,\n\t]\n\t\t.filter(v => typeof v !== 'undefined')\n\t\t.join(':')\n\n\tconst note = calleeNote\n\t\t? ` [${calleeNote}]`\n\t\t: ''\n\n\treturn callee\n\t\t? `${callee}${note} (${sourceTrace})`\n\t\t: sourceTrace\n}\n\nexport function formatEvalTrace({\n\tcallee,\n\tevalTrace,\n\n\tevalCallee,\n\tevalCalleeNote,\n\n\t...trace\n}: IEvalTrace)\n{\n\treturn `${callee} (eval at ${formatTrace({\n\t\t...trace,\n\n\t\tcallee: evalCallee ?? '<anonymous>',\n\t\tcalleeNote: evalCalleeNote,\n\t})}, ${formatTrace(evalTrace)})`;\n}\n\nexport function formatMessagePrefix({\n\ttype,\n\tcode,\n}: IParsedWithoutTrace)\n{\n\tif (code?.length)\n\t{\n\t\ttype += ` [${code}]`;\n\t}\n\n\treturn `${type}`;\n}\n\nexport function formatMessage(parsed: IParsedWithoutTrace)\n{\n\treturn `${formatMessagePrefix(parsed)}: ${parsed.message ?? ''}`;\n}\n\nexport function formatRawLineTrace(trace: IRawLineTrace)\n{\n\treturn `${trace.indent ?? '    '}${trace.rawLine}`\n}\n\nexport function isRawLineTrace(trace: ITraceValue): trace is IRawLineTrace\n{\n\treturn (trace.raw === true)\n}\n\nexport function isEvalTrace(trace: ITraceValue): trace is IEvalTrace\n{\n\treturn (trace as IEvalTrace).eval === true\n}\n\nexport function formatTraceLine(trace: ITraceValue)\n{\n\tif (isRawLineTrace(trace))\n\t{\n\t\treturn formatRawLineTrace(trace)\n\t}\n\n\treturn `${trace.indent ?? '    '}at ${\n\t\tisEvalTrace(trace)\n\t\t\t? formatEvalTrace(trace)\n\t\t\t: formatTrace(trace)\n\t}`\n}\n\nexport class ErrorStack implements IParsed\n{\n\n\t/**\n\t * Error type\n\t */\n\ttype: string;\n\n\tcode?: string;\n\t/**\n\t * The message used by Error constructor\n\t */\n\tmessage: string;\n\ttraces: IParsed[\"traces\"];\n\n\treadonly rawMessage?: string;\n\treadonly rawTrace?: string[];\n\treadonly rawStack?: string;\n\n\tconstructor(stack: string, detectMessage?: string)\n\t{\n\t\tObject.assign(this, parseStack(stack, detectMessage))\n\t}\n\n\t/**\n\t * filterFunction Function the same as the callback function of Array.prototype.filter(callback)\n\t */\n\tfilter(filter: (value: ITraceValue, index: number, array: IParsed[\"traces\"]) => boolean)\n\t{\n\t\tthis.traces = this.traces.filter(filter)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Format object parsed\n\t */\n\tformat()\n\t{\n\t\treturn stringifyErrorStack(this)\n\t}\n}\n\nexport function formatTraces(traces: IParsed[\"traces\"])\n{\n\treturn traces?.map(formatTraceLine)\n}\n\n/**\n * Format object parsed\n */\nexport function stringifyErrorStack(parsed: ITSRequireAtLeastOne<IParsed, 'traces' | 'rawTrace'>)\n{\n\tconst messageLines = `${formatMessage(parsed)}`\n\tconst tracesLines = (parsed.traces?.map(formatTraceLine) ?? parsed.rawTrace)\n\t\t.join(CR)\n\n\treturn tracesLines\n\t\t? messageLines + CR + tracesLines\n\t\t: messageLines\n}\n\nexport function parseErrorStack(stack: string, detectMessage?: string)\n{\n\treturn new ErrorStack(stack, detectMessage)\n}\n\nexport default parseErrorStack\n"],"names":["trim","s","isUnset","v","isNumOnly","test","toString","AT","CR","REGEX_MATCH_MESSAGE","REGEX_REMOVE_AT","REGEX_STARTS_WITH_EVAL_AT","REGEX_MATCH_INDENT","breakBrackets","str","first","last","endsWith","firstIndex","cursor","length","count","char","charAt","slice","map","validPosition","source","line","col","parseSource","rawSource","ssplit","parseEvalSource","rawEvalSource","indent","rawLine","_detectIndent","rawTrace","rawEvalTrace","replace","split","eval","ev","callee","evalCallee","calleeNote","evalCalleeNote","trace","parseTrace","evalTrace","exec","testEvalSource","t","rawCallee","ret","startsWith","raw","Object","assign","isEvalSource","validTrace","isRawLineTrace","parseBody","rawStack","detectMessage","rawMessage","type","parseMessage","mf","formatMessage","message","i","indexOf","m","R_CRLF","index","lineSplit","input","findIndex","trimLeft","splice","join","body","code","match","e","inspect","errcode","parseStack","TypeError","traces","formatTrace","sourceTrace","filter","note","formatEvalTrace","formatMessagePrefix","parsed","formatRawLineTrace","isEvalTrace","formatTraceLine","ErrorStack","constructor","stack","format","stringifyErrorStack","formatTraces","messageLines","tracesLines","parseErrorStack"],"mappings":"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"}